{{$vid_heap := (call .Video "TH01-Elis-heap-corruption" "Video demonstrating TH01 Elis' HP going below zero, and how rendering negative HP will cause heap corruption") -}}
{{$vid_3_0 := (call .Video "TH01-Elis-pattern-3-original" "Video of TH01 Elis' \"pellets along circle\" pattern in its original version") -}}
{{$vid_3_1 := (call .Video "TH01-Elis-pattern-3-fixed" "Video of TH01 Elis' \"pellets along circle\" pattern, with the pellet camp bumped to 160, fixed blitting for the 4th quadrant of the big circle, and a correctly centered pellet spawn point") -}}
{{$vid_7_e := (call .Video "TH01-Elis-pattern-7-Easy" "Video of the \"slow spread\" pattern of TH01 Elis' bat form on Easy Mode") -}}
{{$vid_7_n := (call .Video "TH01-Elis-pattern-7-Normal" "Video of the \"slow spread\" pattern of TH01 Elis' bat form on Normal Mode") -}}
{{$vid_7_h := (call .Video "TH01-Elis-pattern-7-Hard" "Video of the \"slow spread\" pattern of TH01 Elis' bat form on Hard Mode") -}}
{{$vid_7_l := (call .Video "TH01-Elis-pattern-7-Lunatic" "Video of the \"slow spread\" pattern of TH01 Elis' bat form on Lunatic Mode") -}}
{{$vid_hitbox := (call .Video "TH01-Elis-bat-shot-hitbox" "Video demonstrating the hitboxes of TH01 Elis' bat form") -}}
{{$vid_12 := (call .Video "TH01-Elis-pattern-12" "Video of TH01 Elis' \"safety circle + rain from top\" pattern") -}}
{{$pic_1 := (call .PostFileURL "TH01-Elis-GPF-debug.png") -}}
{{$pic_2 := (call .PostFileURL "TH01-Mima-GPF-debug.png") -}}

{{$vid_3_0.SetTitle "Original version" -}}
{{$vid_3_1.SetTitle "Fixed version" -}}
{{$vid_7_e.SetTitle "Easy" -}}
{{$vid_7_n.SetTitle "Normal" -}}
{{$vid_7_h.SetTitle "Hard" -}}
{{$vid_7_l.SetTitle "Lunatic" -}}

{{$vid_12.AddMarker 117 "Circle activates" "right" -}}
{{$vid_12.AddMarker 317 "Circle disappears" "left" -}}

{{$mod := printf "%v%v" .DatePrefix "community-choice-fixes.zip" -}}

<p>
	With Elis, we've not only reached the midway point in TH01's boss code, but
	also a bunch of other milestones: Both <code>REIIDEN.EXE</code> and TH01 as
	a whole have crossed the 75% RE mark, and overall position independence has
	also finally cracked 80%!
</p><p>
	And it got done in 4 pushes again? Yup, we're back to
	{{Blog_PostLink "2021-08-23" "Konngara"}} levels of redundancy and
	copy-pasta. This time, it didn't even stop at the big copy-pasted code
	blocks for the rift sprite and 256-pixel circle animations, with the words
	"redundant" and "unnecessary" ending up a total of 18 times in my source
	code comments.<br />
	But damn is this fight broken. As usual with TH01 bosses, let's start with a
	high-level overview:
</p><ul>
	<li>The Elis fight consists of 5 phases (excluding the entrance animation),
	which must be completed in order.</li>
	<li>In all odd-numbered phases, Elis uses a random one-shot danmaku pattern
	from an exclusive per-phase pool before teleporting to a random
	position.<ul>
		<li>There are 3 exclusive girl-form patterns per phase, plus 4
		additional bat-form patterns in phase 5, for a total of 13.</li>
		<li>Due to a quirk in the selection algorithm in phases 1 and 3, there
		is a 25% chance of Elis skipping an attack cycle and just teleporting
		again.</li>
		<li>In contrast to Konngara, Elis can freely select the same pattern
		multiple times in a row. There's nothing in the code to prevent that
		from happening.</li>
	</ul></li>
	<li>This pattern+teleport cycle is repeated until Elis' HP reach a certain
	threshold value. The odd-numbered phases correspond to the white (phase 1),
	red-white (phase 3), and red (phase 5) sections of the health bar. However,
	the next phase can only start at the end of each cycle, after a
	teleport.</li>
	<li>Phase 2 simply teleports Elis back to her starting screen position of
	(﻿320,&nbsp;144﻿) and then advances to phase 3.</li>
	<li>Phase 4 does the same as phase 2, but adds the initial bat form
	transformation before advancing to phase 5.</li>
	<li>Phase 5 replaces the teleport with a transformation to the bat form.
	Rather than teleporting instantly to the target position, the bat gradually
	flies there, firing a randomly selected looping pattern from the 4-pattern
	bat pool on the way, before transforming back to the girl form.</li>
</ul><p>
	This puts the earliest possible end of the fight at the first frame of phase
	5. However, nothing prevents Elis' HP from reaching 0 before that point. You
	can nicely see this in {{Blog_PostLink "2020-05-12" "debug mode"}}: Wait
	until the HP bar has filled up to avoid heap corruption, hold ↵&nbsp;Return
	to reduce her HP to 0, and watch how Elis still goes through a total of
	<span class="hovertext" title="With each of them having the aforementioned
	25% chance of being replaced with a teleport.">two patterns*</span> and four
	teleport animations before accepting defeat.
</p><p>
	But wait, heap corruption? Yup, there's a bug in the HP bar that already
	affected Konngara as well, and it isn't even <i>just</i> about the graphical
	glitches generated by negative HP:
</p><ul>
	<li>Because {{Blog_PostLink "2020-12-18" "the backgrounds behind the points	are kept in main memory"}},
	there has to be a cap on the number of hitpoints, which turns out to be
	96.</li>
	<li>The initial fill-up animation is drawn to both VRAM pages at a rate of 1
	HP per frame… by passing the current frame number as the
	<code>current_hp</code> number. {{HTML_Emoji "tannedcirno"}}</li>
	<li>The <code>target_hp</code> is indicated by simply passing the current
	HP…</li>
	<li>… which, however, can be reduced in debug mode at an equal rate of up to
	1 HP per frame.</li>
	<li>The completion condition only checks if
	<code>((target_hp&nbsp;-&nbsp;1)&nbsp;==&nbsp;current_hp)</code>. With the
	right timing, both numbers can therefore run past each other.</li>
	<li>In that case, the function is repeatedly called on every frame, backing
	up the original VRAM contents for the current HP point before blitting
	it…</li>
	<li>… until frame <code>((96&nbsp;/&nbsp;2)&nbsp;+&nbsp;1)</code>, where the
	.PTN slot pointer overflows the heap buffer and overwrites whatever comes
	after. {{Blog_PostLink "2020-11-30" "Sounds familiar, right?"}}
</ul><p>
	Since Elis starts with 14 HP, which is an even number, this corruption is
	trivial to cause: Simply hold ↵&nbsp;Return from the beginning of the
	fight, and the completion condition will never be <code>true</code>, as the
	HP and frame numbers run past the off-by-one meeting point.
</p><figure {{$vid_heap.FigureAttrs}}>
	{{call .VideoPlayer $vid_heap.SetNoLoop}}
	<figcaption>
		<strong>Edit (2023-07-21):</strong> Pressing ↵&nbsp;Return to reduce HP
		also works in test mode (<code>game t</code>). There, the game doesn't
		even check the heap, and consequently won't report any corruption,
		allowing the HP bar to be glitched even further.
	</figcaption>
</figure><p>
	Regular gameplay, however, entirely prevents this due to the fixed start
	positions of Reimu and the Orb, the Orb's fixed initial trajectory, and the
	50 frames of delay until a bomb deals damage to a boss. These aspects make
	it impossible to hit Elis within the first 14 frames of phase 1, and ensure
	that her HP bar is always filled up completely. So ultimately, this bug ends
	up comparable in seriousness to the
	{{Blog_PostLink "2020-05-12" "recursion&nbsp;/ stack overflow bug in the memory info screen"}}.
</p><hr /><p>
	These wavy teleport animations point to a quite frustrating architectural
	issue in this fight. It's not even the fact that unblitting the yellow star
	sprites rips temporary holes into Elis' sprite; that's almost expected from
	TH01 at this point. Instead, it's all because of this unused frame of the
	animation:
</p><figure class="pixelated"><img
src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAABgBAMAAAAnVGd6AAAAIVBMVEUAAADw8PDw0LDQoJCwoABgYGDQAACAEBAwMDCgAABwAFDmaxhHAAAAAXRSTlMAQObYZgAAAhpJREFUeAHtwUF24zgQBcEPAqzJyvsfeB4oyfZ095KahdsR+TMueQHI3wlAlUsSLj5A3gZwgwTIRpLgBcjtADdIQjckAZIEHyDvAF5IEqq7gK4iJPhE3gfwQrYqtsWWBFEFyNsBqkAurLUWQP1DJUG8APkL4BMhCQtYTBZAkoAPuRm+kEzCMRbMyXaQBPxAboIvJJmsNWHOybHgYPMTuZkXknCsCRxzcsBiHhP8BHkLVFGShAVyHHgUExIALwh5IwA3FBLmoo6DOY/jYC1ARcUN8p3hf8AEJsdRx3GwFguOAx/y4wZe1mROxqCLCc05xoA5WfiJvIGKyFprMU6qm+4qxhgs1gJVQBXyFoCAisBiMQZUFWdXcZ6DxVoLVEAVcj/8AhYLBnSdg0E15wDWWgtfcjt8QV24ZEAzBoNtKGstcMuPG/jpBDhPTp4EtzHEC7mf4guX7obm5EF1jIEXyLeGH/AJoLeqbs5T0KEOH3I3/B3Q3VVdVd1sw5d8A+AT+ELXh27cUAIoQSA3EV+or7q9kCRIkii5HYoCKvULVEkSyAXI94ZkA5IE7fpVq7mQ98A8QDao3yHZyL0gD+RC/QHkbpgHcqG+6rpANvIEuQ/ZqM2ytu6q0iIbeYH8eD/yRBJKyyqtS1tbk4S8EXkhoT5YCpZVBUnI/cgXXU9WVXV3VxWahNyMPBEeuru23kDJF5DbkShbPwCa/8G/V+gpftGVucEAAAAASUVORK5CYII="
alt="An unused wave animation frame from TH01's BOSS5.BOS" style="height: 96px;"
/>
</figure><p>
	With this sprite still being part of <code>BOSS5.BOS</code>, Girl-Elis has a
	total of 9 animation frames, 1 more than the
	{{Blog_PostLink "2020-08-12" "8 per-entity sprites allowed by ZUN's architecture"}}.
	The quick and easy solution would have been to simply bump the sprite array
	size by 1, but… nah, this would have added another 20 bytes to all 6 of the
	.BOS image slots. {{HTML_Emoji "zunpet"}} Instead, ZUN wrote the manual
	position synchronization code I mentioned in that 2020 blog post.
	Ironically, he then copy-pasted this snippet of code often enough that it
	ended up taking up more than 120 bytes in the Elis fight alone – with, you
	guessed it, some of those copies being redundant. Not to mention that just
	going from 8 to 9 sprites would have allowed ZUN to go down from 6 .BOS
	image slots to 3. That would have actually <i>saved</i> 420 bytes in
	addition to the manual synchronization trouble. Looking forward to SinGyoku,
	that's going to be fun again…
</p><hr /><p>
	As for the fight itself, it doesn't take long until we reach its most janky
	danmaku pattern, right in phase 1:
</p><figure {{$vid_3_0.FigureAttrs}}>
	{{call .VideoPlayer $vid_3_0.SetActive $vid_3_1}}
	<figcaption>
		The "pellets along circle" pattern on Lunatic, in its original version
		and with fanfiction fixes for everything that can potentially be
		interpreted as a bug.
	</figcaption>
</figure><ul>
	<li>For whatever reason, the lower-right quarter of the circle isn't
	animated? This animation works by only drawing the new dots added with every
	subsequent animation frame, expressed as a tiny arc of a dotted circle. This
	arc starts at the animation's current 8-bit angle and ends on the sum of
	that angle and a hardcoded constant. In every other (copy-pasted, and
	correct) instance of this animation, ZUN uses <code>0x02</code> as the
	constant, but this one uses… <code>0.05</code> for the lower-right quarter?
	As in, a 64-bit <code>double</code> constant that truncates to 0 when added
	to an 8-bit integer, thus leading to the start and end angles being
	identical and the game not drawing anything.</li>
	<li>On Easy and Normal, the pattern then spawns 32 bullets along the outline
	of the circle, no problem there. On Lunatic though, every one of these
	bullets is instead turned into a narrow-angled 5-spread, resulting in 160
	pellets… in a game with a pellet cap of 100. {{HTML_Emoji "onricdennat"}}
	Now, if Elis teleported herself to a position near the top of the playfield,
	most of the capped pellets would have been clipped at that top edge anyway,
	since the bullets are spawned in clockwise order starting at Elis' right
	side with an angle of <code>0x00</code>. On lower positions though, you can
	definitely see a difference if the cap were high enough to allow all coded
	pellets to actually be spawned.<br />
	The Hard version gets dangerously close to the cap by spawning a total of 96
	pellets. Since this is the only pattern in phase 1 that fires pellets
	though, you are guaranteed to see all of the unclipped ones.</li>
	<li>The pellets also aren't spawned exactly on the telegraphed circle, but 4 pixels to the left.</li>
</ul><p>
	Then again, it might very well be that all of this was intended, or, most
	likely, just left in the game as a happy accident. The latter interpretation
	would explain why ZUN didn't just delete the rendering calls for the
	lower-right quarter of the circle, because seriously, how would you not spot
	that? The phase 3 patterns continue with more minor graphical glitches that
	aren't even worth talking about anymore.
</p><hr /><p>
	And then Elis transforms into her bat form at the beginning of Phase 5,
	which displays some rather unique hitboxes. The one against the Orb is fine,
	but the one against player shots…
</p><figure>{{call .VideoPlayer $vid_hitbox}}</figure><p>
	… uses the bat's X coordinate for both X and Y dimensions.
	{{HTML_Emoji "zunpet"}} In regular gameplay, it's not <i>too</i> bad as most
	of the bat patterns fire aimed pellets which typically don't allow you to
	move below her sprite to begin with. But if you ever tried destroying these
	pellets while standing near the middle of the playfield, now you know why
	that didn't work. This video also nicely points out how the bat, like any
	boss sprite, is only ever blitted at positions on the 8×1-pixel VRAM byte
	grid, while collision detection uses the actual pixel position.
</p><p>
	The bat form patterns are all relatively simple, with little variation
	depending on the difficulty level, except for the "slow pellet spreads"
	pattern. This one is almost easiest to dodge on Lunatic, where the 5-spreads
	are not only always fired downwards, but also at the hardcoded narrow delta
	angle, leaving plenty of room for the player to move out of the way:
</p><figure {{$vid_7_e.FigureAttrs}}>
	{{call .VideoPlayer $vid_7_e $vid_7_n $vid_7_h $vid_7_l.SetActive}}
	<figcaption>The "slow pellet spreads" pattern of Elis' bat form, on every
	difficulty. Which version do you think is the easiest one?</figcaption>
</figure><p>
	Finally, we've got another potential timesave in the girl form's "safety
	circle" pattern:
</p><figure>{{call .VideoPlayer $vid_12}}</figure><p>
	After the circle spawned completely, you lose a life by moving outside it,
	but doing that immediately advances the pattern past the circle part. This
	part takes 200 frames, but the defeat animation only takes 82 frames, so
	you can save up to 118 frames there.
</p><p>
	Final funny tidbit: As with all dynamic entities, this circle is only
	blitted to VRAM page 0 to allow easy unblitting. However, it's also kind of
	static, and there needs to be some way to keep the Orb, the player shots,
	and the pellets from ripping holes into it. So, ZUN just re-blits the circle
	every… 4 frames?! 🤪 The same is true for the Star of David and its
	surrounding circle, but there you at least get a flash animation to justify
	it. All the overlap is actually quite a good reason for not even attempting
	to {{Blog_PostLink "2021-11-08" "mess with the hardware color palette instead"}}.
</p><hr /><p>
	And that's the 4th PC-98 Touhou boss decompiled, 27 to go… but wait, all
	these quirks, and I still got nothing about <a
	href="https://youtu.be/Al0KTB_0u4A?t=80">the one actual crash that can
	appear in regular gameplay</a>? <a
	href="https://www.youtube.com/watch?v=3YjHkrJ1BBM">There has even been a
	recent video about it.</a> The cause <i>has</i> to be in Elis' main
	function, after entering the defeat branch and before the blocking white-out
	animation. It <i>can't</i> be anywhere else other than in the
	{{Blog_PostLink "2020-01-14" "central line blitting and unblitting 	function"}},
	called from {{Blog_PostLink "2020-10-06" "that one broken laser reset+unblit function"}},
	because everything else in that branch looks fine… and I think we can rule
	out a crash in MDRV2's non-blocking fade-out call. That's going to need some
	extra research, and a 5th push added on top of this delivery.
</p><p>
	Reproducing the crash was the whole challenge here. Even after moving Elis
	and Reimu to the exact positions seen in Pearl's video and setting Elis' HP
	to 0 on the exact same frame, everything ran fine for me. It's definitely no
	division by 0 this time, the function perfectly guards against that
	possibility. The line specified in the function's parameters is always
	clipped to the VRAM region as well, so we can also rule out illegal memory
	accesses here…
</p><p>
	… or can we? Stepping through it all reminded me of how this function brings
	unblitting sloppiness to the next level: For each VRAM byte touched, ZUN
	actually unblits <i>the 4 surrounding bytes</i>, adding one byte to the left
	and two bytes to the right, and using a single 32-bit read and write per
	bitplane. So what happens if the function tries to unblit the topmost byte
	of VRAM, covering the pixel positions from (﻿0,&nbsp;0﻿) to (﻿7,&nbsp;0﻿)
	inclusive? The VRAM offset of <code>0x0000</code> is decremented to
	<code>0xFFFF</code> to cover the one byte to the left, 4 bytes are written
	to this address, the CPU's internal offset overflows… and as it turns out,
	that is illegal even in Real Mode as of the 80286, and <span
	class="hovertext" title="Bug counter: 1">will raise a General Protection
	Fault</span>. Which is… ignored by <a
	href="https://github.com/joncampbell123/dosbox-x/issues/3526">DOSBox-X</a>,
	every Neko Project II version in common use, the <a
	href="http://takeda-toshiya.my.coocan.jp/common/index.html">CSCP
	emulators</a>, SL9821, and T98-Next. Only Anex86 accurately emulates the
	behavior of real hardware here.
</p><p>
	OK, but no laser fired by Elis ever reaches the top-left corner of the
	screen. How can such a fault even happen in practice? That's where the
	broken laser reset+unblit function comes in: Not only does it just <span
	class="hovertext" title="Bug counter: 2">flat out pass the wrong
	parameters</span> to the line unblitting function – describing the line
	<i>already traveled</i> by the laser and stopping where the laser begins –
	but it also <span class="hovertext" title="Bug counter: 3">passes them
	wrongly, in the form of raw 32-bit fixed-point Q24.8 values</span>, with no
	conversion other than a truncation to the signed 16-bit pixels expected by
	the function. What then follows is an attempt at interpolation and clipping
	to find a line segment between those garbage coordinates that actually falls
	within the boundaries of VRAM:
</p><ol>
	<li><code>right/bottom</code> correspond to a laser's origin position, and
	<code>left/top</code> to the leftmost pixel of its moved-out top line. The
	bug therefore only occurs with lasers that stopped growing and have started
	moving.</li>
	<li>Moreover, it will only happen if either <code>(left % 256)</code> or
	<code>(right % 256)</code> is ≤ 127 and the other one of the two is ≥ 128.
	The typecast to signed 16-bit integers then turns the former into a large
	positive value and the latter into a large negative value, triggering the
	function's clipping code.</li>
	<li>The function then follows <a
	href="https://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm">Bresenham's
	algorithm</a>: <code>left</code> is ensured to be smaller than right</code>
	by swapping the two values if necessary. If that happened, <code>top</code>
	and <code>bottom</code> are also swapped, regardless of their value – the
	algorithm does not care about their order.</li>
	<li>The slope in the X dimension is calculated using an integer division of
	<code>(﻿(﻿bottom&nbsp;-&nbsp;top﻿)&nbsp;/
	(﻿right&nbsp;-&nbsp;left﻿)﻿)</code>. Both subtractions are done on signed
	16-bit integers, and overflow accordingly.</li>
	<li><code>(-left&nbsp;×&nbsp;slope_x)</code> is added to <code>top</code>,
	and <code>left</code> is set to 0.</li>
	<li>If both <code>top</code> and <code>bottom</code> are &lt; 0 or
	≥&nbsp;640, there's nothing to be unblitted. Otherwise, the final
	coordinates are clipped to the VRAM range of [﻿(﻿0,&nbsp;0﻿),
	(﻿639,&nbsp;399﻿)﻿].</li>
	<li>If the function got this far, the line to be unblitted is now very
	likely to reach from<ol>
		<li>the top-left to the bottom-right corner, starting out at
		(﻿0,&nbsp;0﻿) right away, or</li>
		<li>from the bottom-left corner to the top-right corner. In this case,
		you'd expect unblitting to end at (﻿639,&nbsp;0﻿), but thanks to an
		<span class="hovertext" title="Bug counter: 4">off-by-one error</span>,
		it actually ends at (﻿640,&nbsp;-1﻿), which is equivalent to
		(﻿0,&nbsp;0﻿). Why add clipping to VRAM offset calculations when
		everything else is clipped already, right? {{HTML_Emoji "godzun"}}</li>
	</ol></li>
</ol><figure class="side_by_side">
	<img src="{{$pic_1}}" class="th01_playfield" />
	<img src="{{$pic_2}}" class="th01_playfield" />
	<figcaption>Possible laser states that will cause the fault, with some debug
	output to help understand the cause, and any pellets removed for better
	readability. This can happen for all bosses that can potentially have
	shootout lasers on screen when being defeated, so it also applies to Mima.
	Fixing this is easier than understanding why it happens, but since y'all
	love reading this stuff…</figcaption>
</figure><p>
	tl;dr: TH01 has a high chance of freezing at a boss defeat sequence if there
	are diagonally moving lasers on screen, <i>and</i> if your PC-98 system
	raises a General Protection Fault on a 4-byte write to offset
	<code>0xFFFF</code>, <i>and</i> if you don't run a TSR with an <code>INT
	0Dh</code> handler that might handle this fault differently.
</p><p>
	The easiest fix option would be to just remove the attempted laser
	unblitting entirely, but that would also have an impact on this game's…
	<i>distinctive</i> visual glitches, in addition to touching a whole lot of
	code bytes. If I ever get funded to work on a hypothetical TH01 Anniversary
	Edition that completely rearchitects the game to fix all these glitches, it
	would be appropriate there, but not for something that purports to be the
	original game.
</p><p>
	(Sidenote to further hype up this Anniversary Edition idea for PC-98
	hardware owners: With the amount of performance left on the table at every
	corner of this game, I'm pretty confident that we can get it to work
	decently on PC-98 models with just an 80286 CPU.)
</p><p>
	Since we're in critical infrastructure territory once again, I went for the
	most conservative fix with the least impact on the binary: Simply changing
	any VRAM offsets <code>&gt;= 0xFFFD</code> to <code>0x0000</code> to avoid
	the GPF, and leaving all other bugs in place. Sure, it's rather lazy and
	"incorrect"; the function still unblits a 32-pixel block there, but adding a
	special case for blitting 24 pixels would add way too much code. And
	seriously, it's not like anything happens in the 8 pixels between
	(﻿24,&nbsp;0﻿) and (﻿31,&nbsp;0﻿) inclusive during gameplay to begin with.
	To balance out the additional per-row <code>if()</code> branch, I inlined
	the VRAM page change I/O, saving two function calls and one memory write per
	unblitted row.
</p><p>
	That means it's time for a new <a
	href="https://github.com/nmlgc/ReC98/tree/community_choice_fixes"><code>community_choice_fixes</code></a>
	build, containing the new definitive bugfixed versions of these games:
	{{HTML_Download .HostedPath $mod}}
	Check the <a
	href="https://github.com/nmlgc/ReC98/tree/th01_critical_fixes"><code>th01_critical_fixes</code></a>
	branch for the modified TH01 code. It also contains a fix for the HP bar
	heap corruption in test or debug mode – simply changing the <code>==</code>
	comparison to <code>&lt;=</code> is enough to avoid it, and negative HP will
	still create aesthetic glitch art.
</p><hr /><p>
	Once again, I then was left with ½ of a push, which I finally filled with
	some <code>FUUIN.EXE</code> code, specifically the verdict screen. The most
	interesting part here is the player title calculation, which is quite
	sneaky: There are only 6 skill <i>levels</i>, but three <i>groups</i> of
	titles for each level, and the title you'll see is picked from a random
	group. It looks like this is the first time anyone has documented the
	calculation?<br />
	As for the levels, ZUN definitely didn't expect players to do particularly
	well. With a 1cc being the standard goal for completing a Touhou game, it's
	especially funny how TH01 expects you to continue <i>a lot</i>: The code has
	branches for up to 21 continues, and the on-screen table explicitly leaves
	room for 3 digits worth of continues <i>per 5-stage scene</i>. Heck, these
	counts are even stored in 32-bit <code>long</code> variables.
</p><p>
	Next up: {{Blog_PostLink "2021-07-20" "Finally finishing"}} the long
	overdue {{DB_CustomerByID 9}} MediaWiki update work, while continuing with
	Kikuri in the meantime. Originally I wasn't sure about what to do between
	Elis and <a href="https://twitter.com/ReC98Project/status/1521279556174417920">Seihou</a>,
	but with {{DB_CustomerByID 13}}'s surprise
	<script>formatCurrency(2000)</script> contribution last week, y'all have
	demonstrated more than enough interest in the idea of getting TH01 done
	sooner rather than later. And I agree – after all, we've got the 25th
	anniversary of its first public release coming up on August 15, and I might
	still manage to completely decompile this game by that point…
</p>
