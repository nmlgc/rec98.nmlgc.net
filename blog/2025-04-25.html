{{$kex := (call .PostFileURL "KernelEx-properties.webp") -}}
{{$d3dw_fg := (call .PostFileURL "D3DWindower-Foreground-Control.webp") -}}
{{$w98_screenshots := (call .PostFileURL "Windows-98-screenshots.webp") -}}
{{$w98_bgmpack := (call .PostFileURL "Windows-98-BGM-pack.webp") -}}
{{$w98_golf := (call .PostFileURL "Windows-98-Golf-course.webp") -}}
{{$mojibake := (call .PostFileURL "SH01-Music-Room-mojibake.webp") -}}

<p>
	Backporting my Shuusou Gyoku build to Windows 98 was one of my favorite commissions in recent history. If you remember {{Blog_PostLink "2024-07-09#tiers" "last year's backport of the overhauled ReC98 build system to Windows 9x"}}, it left me rather demoralized at the end of it all. Sure, it may be the technically fastest way of fully rebuilding the entire codebase, but it just doesn't matter to me personally – incremental rebuilds on modern systems are still faster and much better integrated with the editors I actually use. People might have appreciated the research that went into it, as usual, but it just feels so pointless if nobody actually uses the result. So why are we treating Windows 9x compatibility as this noble goal and ideal expectation again? Just because retro-computing communities exist and prefer to paint it that way? The length of this post should hopefully make it clear that this is nothing that should be demanded or taken for granted.<br>
	That's why seeing this goal in particular getting funded was such a refreshing change of perspective. Finally, retro-computing people have put their money where their mouth is, and invested in something other than hardware! 🙌
</p>{{call .TOC}}<hr id="strategy-{{.Date}}"><p>
	So, how <i>do</i> you backport a modern C++ project to Windows 98 in 2025? Visual Studio removed official support for such old systems a long time ago, and increasingly uses newfangled Win32 API functions in its C++ standard library implementations where they can't be trivially removed.<br>
	If your codebase of choice restricts itself to old C and C++ standards, compiling it with an old version of Visual Studio can get you most of the way there. But this is becoming increasingly unlikely as we only ever move further away from the mid-90s. After all, this restriction would not only have to apply to a project's own code, but to all of its dependencies as well, since a backport can't just fall back on precompiled libraries. And then, all bets are off – some projects like miniaudio <a href="https://github.com/mackron/miniaudio/pull/140">might be committed to supporting Visual C++ 6</a>, but others might just freely use whatever language features are available on the GCC version that is part of the oldest Linux image offered by their CI provider. Which is totally understandable: <a href="https://www.youtube.com/watch?v=wrwwa68JXNk">There is a reason behind new language versions</a>, and at some point, developers just want to move on and stop taking productivity hits all the time. Or just prefer to try something new, because C89 in particular sure gets old after writing a 5-digit number of lines in it, at least as far as I'm concerned. I'm still hoping that I get to statically recompile Turbo C++ 4.0J one day and add at least a few more language features and code optimizations to it…<br>
	Also, having simple and accessible build processes has always been a guiding principle of mine. If people can't compile with widely available tools and have to acquire old proprietary compilers from legally dubious sources, I don't fully deliver on a key promise of free software, which is kind of important to me.
</p><p>
	But as long as the Windows 98 users are willing to install KernelEx, we can get very far with even current Visual Studio versions. KernelEx covers most of those newfangled Win32 API functions, and even helpfully makes Windows ignore the <code>*OperatingSystemVersion</code> fields in the PE header. The only thing we should manually add to the build process is the <code>/arch:IA32</code> flag: It removes any modern x86 instructions in newly-compiled code and thus ensures that the game still runs on period-correct CPUs. Of course, <a href="https://github.com/nmlgc/ssg/issues/84">the modern build should use all modern instructions it possibly can</a>, but it makes sense to limit Windows 98 support to the alternate build with pbg's original DirectDraw and Direct3D graphics and add the flag there.<br>
	And sure enough, {{Blog_PostLink "2023-08-01#strategy" "this worked out beautifully for the first few releases of my Shuusou Gyoku fork"}}. But once I added more features, running on Windows 98 became increasingly harder:
</p><ul>
	<li><a href="https://github.com/nmlgc/ssg/releases/tag/P0256">P0256</a> required an extra <a href="https://learn.microsoft.com/en-us/cpp/build/reference/zc-threadsafeinit-thread-safe-local-static-initialization"><code>/Zc:threadSafeInit-</code></a> to not use certain Win32 lock functions that KernelEx doesn't cover.</li>
	<li><a href="https://github.com/nmlgc/ssg/releases/tag/P0275">P0275</a> then started using the filesystem and thread features from modern C++, whose Microsoft STL implementations used enough unimplemented Win32 functions that I was forced to drop Windows 98 support for the time being. It sure doesn't help that KernelEx development has never escaped the increasingly locked-down forum it started in, which has made new builds increasingly inaccessible.</li>
	<li>Meanwhile, Microsoft's C runtime had started to steadily remove more and more workarounds that were required to run on Windows 9x, after they've probably annoyed the developers for long enough.</li>
</ul><p>
	So let's finally give this backport the dedicated attention it needs, and start the usual backporting loop:
</p><ol>
	<li>Encounter one of the classic DLL function errors at startup</li>
	<li>Look at the disassembly to figure out where that call came from</li>
	<li>Either rewrite the offending code to not use the function, or find some way of polyfilling it if the call originated from code that is not under your direct control</li>
	<li>Repeat until the game works</li>
	<li>Follow the same steps for any crashes or weird behavior introduced by the older Windows version</li>
</ol><p>
	There is some room for creativity in this process, as well as non-zero hack value and enjoyment from seeing it all work out in the end. Heck, <a href="https://www.youtube.com/watch?v=CTUMNtKQLl8">MattKC even made a blockbuster feature film out of it</a>. But ultimately, it's dumb drudge work that wouldn't be worth doing if no actual person cares.<br>
	And I haven't even mentioned the worst part: Setting up a full-featured, bug-free, and performant VM that connects to your development system in a sort of comfortable way – and then repeating this process for different language versions of Windows 98, and even for Windows XP and maybe 7 when it comes to debugging DirectDraw issues. This only gets harder as the required dedicated VM code for these old systems starts to bit-rot, which left apparently every VM software out there with at least one deprecated or already removed feature…
</p><hr id="9xcompat-{{.Date}}"><p>
	So, let's start by looking at the Win32 API functions referenced by Microsoft's C runtime, and <a href="https://github.com/nmlgc/9xcompat">create a separate project for any required polyfills</a> so that they would never annoy anyone. I only found out later that <a href="https://building.enlyze.com/posts/modern-visual-studio-meets-ancient-windows/">someone else had the same idea</a>, but <a href="https://building.enlyze.com/posts/targeting-25-years-of-windows-with-visual-studio-2019/">quickly moved on to targeting Clang due to hitting a roadblock with <code>std::mutex</code></a> and <a href="https://github.com/enlyze/EnlyzeWinCompatLib/issues/1">only ever wanted to target NT kernels anyway</a>. So there definitely was a point to me starting a new project there. It also gave me the chance to approach the whole <a href="https://building.enlyze.com/posts/modern-visual-studio-meets-ancient-windows/#overwriting-dll-imports">problem of overwriting and redirecting DLL imports</a> from multiple angles, which led me to arrive at two slightly different solutions. Check the project's README for more details on that.<br>
	After I previously {{Blog_PostLink "2025-04-09#sdl3" "migrated all C++ threading code to SDL as part of the Linux port"}}, I only needed to polyfill a total of 8 functions to get the game back running:
</p><ul>
	<li><a href="https://learn.microsoft.com/en-us/windows/win32/api/fibersapi/">The 4 fiber-local storage API functions</a> (<code>Fls*()</code>), which we redirect to the corresponding <code>Tls*()</code> functions just like Microsoft did in earlier Windows SDK versions.</li>
	<li><a href="https://learn.microsoft.com/en-us/windows/win32/api/winnls/nf-winnls-getlocaleinfoex"><code>GetLocaleInfoEx()</code></a>, which is used by <code>std::filesystem</code>'s error message implementation. We currently don't use these messages, but the retrieval method still gets linked into the binary because the respective method is part of a vtable.</li>
	<li><a href="https://learn.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-initializecriticalsectionex"><code>InitializeCriticalSectionEx()</code></a>, which bumps the minimum OS requirement to Vista for no reason because the CRT only ever passes <code>0</code> to the <code>Flags</code> parameter. Easily redirected to the older <code>InitializeCriticalSectionAndSpinCount()</code>.</li>
	<li><a href="https://learn.microsoft.com/en-us/windows/win32/api/winnls/nf-winnls-getlocaleinfoex"><code>GetFileInformationByHandleEx()</code></a>, used by <code>std::filesystem</code>'s directory iterator. This was the only specific function needed to get BGM modding working.</li>
	<li><a href="https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-findfirstfileexw"><code>FindFirstFileExW()</code></a>, which is also used by, you guessed it, <code>std::filesystem</code>. The CRT uses the <a href="https://www.wholetomato.com/blog/2024/11/14/how-to-query-file-attributes-50x-faster-on-windows/">sometimes faster</a> <a href="https://learn.microsoft.com/en-us/windows/win32/api/minwinbase/ne-minwinbase-findex_info_levels"><code>FindExInfoBasic</code> mode introduced in Windows 7</a>, which we simply replace with <code>FindExInfoStandard</code>. For now, we leave the Unicode→ANSI wrapping to the KernelEx-injected <code>unicows.dll</code> from the <a href="https://learn.microsoft.com/en-us/archive/msdn-magazine/2001/october/mslu-develop-unicode-applications-for-windows-9x-platforms-with-the-microsoft-layer-for-unicode">Microsoft Layer for Unicode</a>.</li>
</ul><p>
	Not only were these functions enough to cover Windows 98 with <a href="https://github.com/nmlgc/ssg/issues/43">the one version of KernelEx I managed to snag from the MSFN forum before they disabled downloads</a>, but they also made the game run on unmodified Windows XP again! To completely remove the need for KernelEx and <code>unicows.dll</code>, we'd still have to cover a slightly bigger number of Win32 API functions, though. But now that this push has put all the foundations into place, the chances are good that the next push might already get this done. And at that point, even <a class="goal" href="https://github.com/nmlgc/ssg/issues/43">Windows 95 support</a> wouldn't be far away.<br>
	If it takes longer, it'll probably be due to these two other remaining issues:
</p><ul>
	<li>The game currently crashes every time it's closed on Windows 9x. We can thank the Microsoft Store for that one: Store apps have to be terminated differently than regular Windows programs, but Visual Studio only uses a single (or, as they call it, <q>universal</q>) C runtime for both kinds of programs. As a result, the CRT has to reach deep into the <a href="https://en.wikipedia.org/wiki/Process_Environment_Block">NT Process Environment Block</a> to find out what kind of program it's dealing with, and this structure simply doesn't exist in Windows 9x.
	<figure><pre>extern "C" bool __cdecl __acrt_is_secure_process()
{
    return (NtCurrentTeb()->ProcessEnvironmentBlock->ProcessParameters->Flags & RTL_USER_PROC_SECURE_PROCESS) != 0;
}
</pre><figcaption>Taken from <code>ucrt/internal/peb_access.cpp</code>.</figcaption></figure>
	Working around this one will be slightly more difficult than just polyfilling a single function.</li>
	<li>Current Windows SDK versions have started to use SSE instructions in the <a href="https://learn.microsoft.com/en-us/cpp/build/reference/gs-buffer-security-check?view=msvc-170">initialization code for the buffer security cookie</a>. Requiring SSE may look like a non-issue nowadays, but shuts out a significant chunk of late-90s systems that would otherwise run the game without any issues. <a href="https://twitter.com/Columbio184/status/1914164260076139002/photo/1">This laptop from 1999 with an AMD K6-2 CPU</a>, for example, can no longer run the new build, even though <a href="https://twitter.com/Columbio184/status/1685823332300562433">it flawlessly ran my fork two years ago</a>.</li>
</ul><hr id="zig-{{.Date}}"><p>
	The second issue in particular shows the limits of this approach. It's only a matter of time until Microsoft activates unconditional SSE on every single part of the precompiled CRT, forcing us to reimplement pretty much all of it for continued 9x compatibility.<br>
	This is exactly why I prefer the Zig approach of compiling the C standard library on demand against the chosen CPU model. Looking at Zig's recent progress, I'm very impressed to see that the community has addressed almost {{Blog_PostLink "2023-09-30#zig" "all of my pain points"}} in the 1½ years since I last looked at it. The Zig compiler now has <a href="https://github.com/ziglang/zig/pull/18704">PDB basenames</a>, <a href="https://github.com/ziglang/zig/pull/20059">compilation progress output</a>, <a href="https://ziglang.org/devlog/2025/#2025-02-24">improved UBSan error messages</a>, and <a href="https://ziglang.org/download/0.14.0/release-notes.html#x86-Backend">compilation speed is actively being worked on</a>.<br>
	Unfortunately though, they still <a href="https://ziglang.org/download/0.14.0/release-notes.html#Build-System">break the build system all the time</a>. For a system-level dependency that people can and will use different versions of, that kind of instability is a non-starter. So I'm very likely not going to migrate anything to Zig before the compiler hits 1.0, unless they do a feature freeze or make some other kind of compatibility promise before that point. Oh well, I've put too much effort into <a href="https://github.com/nmlgc/tupblocks">my Tup building blocks</a> to not continue using them for at least a few more years.
</p><p>
	It might seem like <a class="goal" href="https://github.com/nmlgc/ssg/issues/80">compiling with MinGW</a> would be the more reliable alternative here. Even its GCC 14 version still sets the <code>*OperatingSystemVersion</code> and <code>*SubsystemVersion</code> fields to 4.0, indicating Windows 95, when compiling a 32-bit binary. And if MinGW ever decides on a higher default, I'm sure that the <code>--(major|minor)-(os|subsystem)-version</code> linker flags will continue to allow that default to be freely overridden. Unlike Visual Studio 2022's <code>LINK</code> and <code>EDITBIN</code> tools, which refuse OS version 4.0 for no particular reason. 🙄<br>
	However, MinGW is hardcoded to link against the DLL version of Microsoft's C runtime and offers no option of statically linking the CRT, <a href="https://sourceforge.net/p/mingw-w64/discussion/723798/thread/d0f3119ec6/">presumably due to legal reasons</a>. This used to be no problem as its GCC ≤13 versions linked against the generic <code>msvcrt.dll</code>, which is available on Windows 98 as well. But this was bad for <a href="https://devblogs.microsoft.com/oldnewthing/20140411-00/?p=1273">multiple</a> <a href="https://sourceforge.net/p/mingw-w64/wiki2/The%20case%20against%20msvcrt.dll/">reasons</a>. And so, even <i>they</i> ultimately decided that Windows 7 was a reasonable minimum requirement these days and made MinGW's GCC 14 version link against the Universal CRT, with all its <code>api-ms-win-crt-*-l1-1-0</code> DLLs. We can only avoid these DLL dependencies by going <code>-nostdlib</code> and rewriting all our code accordingly – but guess what, we could do the exact same thing on MSVC with <code>/NODEFAULTLIB</code>, without switching compilers.
</p><p>
	Unfortunately, that's the same reason why Zig would make no difference, regardless of whether you use it as a compiler for C/C++ code or write pure Zig. If you build for Windows, you can merely choose between the GNU and MSVC ABI. Then, Zig behaves exactly like the respective C compiler: Select GNU and you get the UCRT dependencies, select MSVC and you get the statically linked Microsoft CRT with all of its aforementioned drawbacks. <a href="https://github.com/ziglang/zig/issues/528">Supposedly, it's possible to bypass MSVC</a>, but the GNU ABI <i>was</i> the answer to the question of <q>compiling without Visual Studio</q> back then. Establishing an easy-to-use third ABI without any dependencies sounds like much more of a research project than just staying with C++.<br>
	Not to mention that <a href="https://ziglang.org/download/0.6.0/release-notes.html#Windows-Support">Zig's Windows version support policy follows Microsoft's extended support lifecycle</a>. Zig 0.6.0 dropped Windows 7 support, and <a href="https://ziglang.org/download/0.11.0/release-notes.html#Windows">Zig 0.11.0 dropped Windows 8.1 support</a>. While <a href="https://github.com/ziglang/zig/issues/7242#issuecomment-736772022">Andrew Kelley is open to non-invasive patches for greater OS support</a>, these could break at any moment and would therefore need consistent maintenance as well.
</p><hr id="sdl-{{.Date}}"><p>
	Surprisingly, SDL 2 has been causing by far the least amount of problems in all of this. <a href="https://github.com/nmlgc/SDL/commit/bf9ff7486b9ae91a10ad722ed078a09404442978">A small adjustment to its threading functions</a> removed its only mandatory reliance on Microsoft CRT code, and KernelEx and <code>unicows.dll</code> then cover any remaining unconditional usage of newer Win32 API functions. Since we already needed a <code>__WIN9X__</code> macro to opt into this change and retain SDL's default behavior on modern systems, I also took the opportunity to disable most of the subsystem backends that are unsupported on Windows 98, shaving a few hundred KB off the DLL's file size.
</p><p>
	This made SDL look even better than {{Blog_PostLink "2025-04-09#sdl3" "the already good impression I got last time"}}. Not only is SDL not a problem, but it's actually the biggest asset we have in a Windows 9x port. And with all the improved subsystems in SDL 3, it becomes so much of an asset that we should ideally just go all in on SDL 3 and make it a hard dependency of even the cross-platform logic code.<br>
	This would be quite a big deal, and it might not immediately be obvious why. Doesn't every one of our supported platforms already depend on SDL anyway? Internally though, my current architecture predates the plan of using SDL and is still designed for the hypothetical case of not using it. After all, <a href="https://github.com/nmlgc/ssg/issues/53">retaining and expanding pbg's old backend code for a slim Windows 98 port without any big dependencies was a viable option that could have been funded</a>. But now that the backers have voted against it, directly architecting all code against SDL 3 would have so many upsides:
</p><ul>
	<li>Since we maintain our own SDL fork for Windows 9x support, we're in full control of its portability. In contrast, recompiling Microsoft's C runtime from the SDK sources shipped with Visual Studio <a href="https://developercommunity.visualstudio.com/t/private-ucrt-from-source/113492#T-N116600">isn't even supported anymore</a>. It might still be <i>possible</i>, but SDL is a much more easily handled and forked dependency.</li>
	<li>SDL already did the work of <a href="https://discourse.libsdl.org/t/31861/4">completely bypassing the C standard library on Windows</a> for its own code. They still use the CRT by default, but we'd simply have to undefine <code>HAVE_LIBC</code> and <code>HAVE_STDIO</code> to opt out of it.</li>
	<li><code>/arch:IA32</code> also applies to SDL code. If we managed to completely purge all precompiled CRT code from the game binary as a result of using SDL functions wherever possible, we would have fully escaped the looming proliferation of SSE code within the CRT and ensured long-term Windows 9x compatibility.</li>
	<li>And given {{Blog_PostLink "2023-09-30#sdl" "SDL's very nature as this incompressible brick of a DLL"}}, it only makes sense to do so. Because I've restricted the cross-platform logic layer to the C/C++ standard library, the game binaries effectively ended up with their own implementations of features that SDL already offers. Most of those come from Microsoft's CRT, but this category also includes some makeshift code of my own that I only had to write to uphold the initial design goal. Breaking this self-imposed restriction would not only simplify the architecture, but also remove a significant amount of <span class="hovertext" title="Which doesn't just mean file size, but also time to link a release build as part of the build process.">bloat</span> from the Windows build and even fix the occasional bug! 🤩 I've already mentioned file handling in the previous blog post, but we'd also gain <a class="goal" href="https://github.com/nmlgc/ssg/issues/87">a more sophisticated and bug-free BMP writer</a>, <a class="goal" href="https://github.com/nmlgc/ssg/issues/23">a standardized and configurable error logging channel</a>, <a href="https://wiki.libsdl.org/SDL3/SDL_strncasecmp">case-insensitive string comparison that doesn't bloat the binary with locale braindeath</a>, a consistently implemented <code>sprintf()</code> that has a defined way of printing 64-bit numbers without the ugly <code>PRId64</code> hack from <code>&lt;inttypes.h&gt;</code>, and probably a bunch of other things I'm missing right now. Heck, we could even <a href="https://miniaud.io/docs/examples/engine_sdl.html">replace miniaudio's backends with the now sane low level of SDL</a> 3's audio subsystem, limiting miniaudio's role to just mixing.</li>
</ul><p>
	In fact, this idea is so convincing that it makes me want to freeze all new feature or backport development for Shuusou Gyoku until it's done. However, we absolutely want to do this with SDL 3 rather than 2 to reap the full set of benefits. This would imply removing the SDL 2 code path for good, but our Flatpak still uses this code path because the Freedesktop SDK will only start shipping SDL 3 with the next update in August. We <i>could</i> compile SDL 3 from source in the meantime, but maybe we shouldn't? {{HTML_Emoji "thonk"}}<br>
	Given the funding situation and general hype, it'll probably be best if I just focus on TH03 until then.
</p><p>
	But once that's done, it would only leave TrueType fonts, MIDI, and graphics rendering as the subsystems that our architecture supports system-specific APIs for – and even MIDI will only be on there <a class="goal" href="https://github.com/nmlgc/ssg/issues/75">until someone funds MIDI support for just a single non-Windows platform</a>.<br>
	You might wonder why graphics rendering is on there, but we can unfortunately never get rid of pbg's original DirectDraw code. The 8-bit mode is just too crucial for getting the game to run decently on the old systems without 3D acceleration that a Windows 9x port is supposed to target. We could try going full GDI in the hope of maybe even being faster <a href="https://lainnet.arcesia.net/misc/np2gdi.html">or more portable</a>, but that would just be another custom backend.<br>
	We <i>could</i>, however, go the opposite route. <a class="goal" href="https://github.com/nmlgc/ssg/issues/88">Turning pbg's old code into an SDL_Renderer backend</a> would facilitate all kinds of backports of pure SDL_Renderer games to that late-90s period of hardware. Those games will probably not run all <i>that</i> well {{Blog_PostLink "2024-10-22#benchmark" "if our benchmark results for software rendering are any indication"}}, but the idea definitely has hack value.<br>
	And why stop there? Let's add a PC-98 backend! {{HTML_Emoji "tannedcirno"}} …yeah, I'm getting off-track.
</p><hr id="d3dwindower-{{.Date}}"><p>
	Speaking of pbg's old rendering path though: <i>Having</i> to run it while debugging the Windows 98 backport comes with the practical problem that <a class="goal" href="https://github.com/nmlgc/ssg/issues/7">we still have no proper windowed mode for it</a>. Multi-monitor support in VMs is sketchy at best, and even <i>if</i> it works, running OllyDbg on a separate virtual monitor next to exclusive fullscreen 8-bit DirectDraw still doesn't prevent these highly disruptive mode switches between the game and debugger windows.
</p><p>
	Fortunately, D3DWindower is old enough to still work on Windows 98 and works well with pbg's original build of Shuusou Gyoku. Unfortunately, {{Blog_PostLink "2023-09-30#fps" "it stopped working as soon as I migrated window creation to SDL 2"}}. But if we put two and two together, we immediately get a theory as to why: <i>Because</i> it works on Windows 98, D3DWindower might only hook the ANSI versions of all the Windows API functions that games can use to enter exclusive fullscreen mode, but SDL uses the Unicode variants. You wouldn't <i>think</i> that a mode-switching API uses potentially localizable strings as part of its parameters, but hey, maybe monitors are treated like files and addressed with names?<br>
	And indeed, SDL uses <a href="https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-changedisplaysettingsexw"><code>ChangeDisplaySettingsExW()</code></a>, but D3DWindower only hooks <code>ChangeDisplaySettingsExA()</code>. Switching from <code>W</code> to <code>A</code> was all it took to get it working again… on modern Windows at least. {{HTML_Emoji "thonk"}} It wasn't enough for Windows 98, but what could we possibly be missing?
</p><p>
	Turns out that KernelEx is the one and only issue there. D3DWindower (or rather, its internally used <a href="https://www.madshi.net/madCodeHookDescription.htm">madCodeHook library</a>) uses <a href="https://learn.microsoft.com/en-us/windows/win32/api/sysinfoapi/nf-sysinfoapi-getversion">the Win32 <code>GetVersion()</code> function</a>, but interchangeably calls it both via its import and via a proc address pointer retrieved directly from <code>kernel32.dll</code>. KernelEx only wraps one of the two, which causes the hooking algorithm to fail as it gets confused by contradictory Windows version numbers.<br>
	The problem with version numbers is that the number-returning function itself has no way of knowing the caller's intent. I can't think of a situation where it wouldn't make more sense to query the presence of a certain OS <i>feature</i> rather than the version number of the entire thing. And so, KernelEx's wrapper makes the understandable choice of returning exactly the version you've configured for the executable:
</p><figure class="pixelated" style="width: 374px">
	<img
		src="{{$kex}}"
		width="374"
		alt="Screenshot of the Windows 98 file property dialog, showing the KernelEx tab for an executable that is configured to use the specific compatbility mode for Windows 2008 SP1"
	><figcaption>
		This will cause the hooked <code>GetVersion()</code> to return <code>0x17710006</code> rather than <code>0xC0000A04</code>.
	</figcaption>
</figure><p>
	madCodeHook, however, uses the version number to pick between the completely different hooking strategies for 9x and NT kernels, and therefore always needs the actual version of the underlying system. Presumably, these different strategies are needed because 9x kernels didn't have the copy-on-write mechanism that allows a process to freely rewrite system DLL code without affecting other processes. Instead, <a href="http://www.icodeguru.com/vc/ProgramingVC/ch10b.htm">9x kernels only have a single global shared instance of all system DLLs, which gets mapped to the same address for every process</a>. This is also why setting code breakpoints within system DLLs on 9x can break the entire system: Since 9x doesn't support hardware breakpoints, debuggers only have the option of writing the <code>INT 3</code> instruction byte (<code>0xCC</code>) to the breakpoint address and then reverting it before resuming execution. But this instruction can only break back into the debugger for the one process that the debugger is attached to. In the meantime, every other process is left with a corrupted instruction stream, and OllyDbg's cryptic <i>Unable to flush cache</i> only describes a single symptom of the ensuing general instability.<br>
	Thankfully, KernelEx lets us disable its <code>GetVersion()</code> wrapper for any specific compatibility mode by editing the respective section of <code>%WINDIR%\KernelEx\Core.ini</code>. For <var>Windows 2008 SP1</var>, the change would be:
</p><figure>
	<pre class="chroma"> [WIN2K8.names]
<span class="gd">-KERNEL32.GetVersion=kexbases.8</span>
<span class="gi">+KERNEL32.GetVersion=std</span></pre>
</figure><p>
	After a reboot, D3DWindower then succeeds in hooking <code>ChangeDisplaySettingsExA()</code> through KernelEx even if the KernelEx-injected Microsoft Layer for Unicode previously redirected <code>ChangeDisplaySettingsExW()</code> to that function.<br>
	Since the ideal definition of a <i>"Windows 98 backport"</i> does not include KernelEx though, it made sense to already go ANSI right now and restore general compatibility with D3DWindower on NT kernels as well. And with one more crucial manual setting that prevents SDL from crashing itself in confusion…
</p><figure class="pixelated" style="width: 358px;">
	<img
		src="{{$d3dw_fg}}"
		width="358"
		alt="Screenshot of the D3DWindower Foreground Control settings that are necessary to prevent SDL from trying to move back into fullscreen mode after the game window lost and regained focus, which will result in a weirdly stretched borderless fullscreen image followed by a crash"
	><figcaption>
		Yes, I would have preferred a nice <code>GIAN07 (Windows 98).exe</code> file name, but D3DWindower unfortunately glitches if binary names contain spaces. If the directory of a hooked executable contains another executable whose name matches the hooked one up to the first space, D3DWindower will run that other executable instead of the intended one. We sure don't want to run the regular <code>GIAN07.exe</code> by accident.
	</figcaption>
</figure><p>
	… we've got the game running in a provisional windowed mode on Windows 9x!
</p><figure class="pixelated" style="width: 1059px;">
	{{define "desc_head"}}Screenshot of the ReC98 Shuusou Gyoku build running in a 640×480 window on a Windows 98 desktop, next to the System Properties window (as usual for backport screenshots) and the D3DWindower window (demonstrating how the game was windowed). The game window shows the{{end -}}
	<rec98-child-switcher><img
		src="{{$w98_screenshots}}"
		class="active"
		data-title="Screenshot menu"
		width="1059"
		alt="{{template "desc_head"}} screenshot submenu introduced in the ReC98 P0309 build, which was definitely not part of pbg's original release."
	><img
		src="{{$w98_bgmpack}}"
		data-title="BGM pack menu"
		width="1059"
		alt="{{template "desc_head"}} BGM pack selection submenu introduced in the ReC98 P0275 build, which was definitely not part of pbg's original release."
	><img
		src="{{$w98_golf}}"
		data-title="D3DWindower golf course bug"
		width="1059"
		alt="{{template "desc_head"}} Stage 3 entrance animation in 8-bit mode, demonstrating how D3DWindower's inaccurate 8-bit color emulation replicates the infamous &quot;golf course&quot; bug."
	><rec98-parent-init></rec98-parent-init></rec98-child-switcher>
	<figcaption>
		I can't stress enough that debugging was the main intention behind this fix. Without scaling options, D3DWindower is not a replacement for a proper windowed mode, <i>and</i> it adds its own bugs on top. {{Blog_PostLink "2023-08-01#palettes" "The P0251 blog post"}} has more detail about how precise an 8-bit DirectDraw emulation has to be to avoid the infamous golf course in Stage 3.
	</figcaption>
</figure><hr id="sjis-{{.Date}}"><p>
	But turning off Unicode in the Windows 98 build of SDL 2 also had one unfortunate drawback: The window title is now <code>???</code> rather than <code lang="ja">秋霜玉</code>, even when running on NT kernels or a Japanese version of Windows 98. That brings us right to the other big complication of this backport:
</p><h3>😩 Handling Shift-JIS and Unicode 😩</h3><p>
	With SDL now using the <code>*A()</code> functions, you might have expected the same mojibake that you'd see in the windowed title bar of pbg's original build. But since we pass UTF-8 to SDL rather than Shift-JIS, the result would always be slightly different. The number of question marks does match the number of codepoints in the string though, which means that SDL does convert from UTF-8 into <i>something</i> before passing the string to Windows. Unfortunately, this target encoding is always pure 7-bit ASCII because <a href="https://github.com/libsdl-org/SDL/blob/90fd2a3cbee5b7ead1f0517d7cc0eba1f3059207/src/stdlib/SDL_iconv.c#L84-L100">SDL's hand-rolled <code>iconv()</code> function only supports that, Latin-1, and the Unicode Transformation Formats</a>.<br>
	This looks like a very bad choice on the surface. Sure, this implementation is meant to be a minimal fallback for systems that don't have <a href="https://man7.org/linux/man-pages/man3/iconv.3.html"><code>iconv(3)</code></a>, but if it uses <i>that</i> library when available, why doesn't it also use <code>WideCharToMultiByte()</code> on Windows? One reason might be right there in the name of that Win32 function: Windows treats UTF-16 as the base encoding from where all other encodings are converted, but SDL (and everyone else) prefers UTF-8 in that role. This allows SDL to directly convert to UTF-32 or Latin-1 without stopping at UTF-16 first.<br>
	But even <i>if</i> SDL offered Win32-powered conversion from UTF-8 into any Win32 codepage, there's still the issue that <code>WideCharToMultiByte(<span class="hovertext" title="ID of the Shift-JIS codepage">932</span>)</code> will most likely just not work on non-Japanese editions of Windows 9x. Since there is no algorithmic mapping between JIS and Unicode, the conversion between these two encodings requires a lookup table. Windows stores this table in <code>C_932.NLS</code>, and there is no guarantee that this file will be installed on anything before Vista.</li>
</ul><p id="sjis-text-{{.Date}}">
	On the other hand, the second screenshot above clearly shows that…
</p><h4>Text rendering</h4>
	…just works for Japanese text? On <i>my</i> Western Windows 98?! Things quickly take a turn once we enter the Music Room though, where we get working Japanese text next to mojibake:
</p><figure class="pixelated">
	<img
		src="{{$mojibake}}"
		width="640"
		alt="Screenshot of Shuusou Gyoku's Music Room in 8-bit mode on Windows 98, playing the title screen theme loaded from a BGM pack. The theme name (「秋霜玉　～ Clockworks」) and the version banner (「秋霜玉    Version 1.005     ★デモ対応版＃★」) internally use UTF-8 strings and show up correctly, but the comment uses Shift-JIS and shows up as mojibake."
	><figcaption>
		It currently also looks like this on Japanese Windows 98 due to, well, <a class="goal" href="https://github.com/nmlgc/ssg/issues/92">me not having tested this case before</a>.
	</figcaption>
</figure><p>
	This disparity is quickly explained: Any text that is either hardcoded or pulled from the Vorbis comment tag of a BGM pack file is in UTF-8 and can be trivially converted to UTF-16. Every piece of mojibake, on the other hand, comes from the original .DAT files, is therefore encoded in Shift-JIS, and fails the conversion to UTF-16 for the aforementioned reasons.<br>
	But seriously, how can UTF-16 text rendering suddenly just work on Windows 9x? Well, contrary to popular (or certainly my) belief, Windows 9x did have functional Unicode variants for a small group of 15 API functions, <a href="https://www.betaarchive.com/wiki/index.php?title=Microsoft_KB_Archive/125671">which just happens to include GDI's <code>TextOutW()</code>, <code>ExtTextOutW()</code>, and <code>GetTextExtentPoint32W()</code></a>. Yup – these empty text areas we were getting for Japanese games on Windows 9x back in the day? All of them were at least partly preventable. The missing <code>C_932.NLS</code> on non-Japanese systems would have still meant empty text boxes if developers preferred storing text in Shift-JIS rather than UTF-8, which they might have wanted to do if their favorite editors were similarly limited. But that's about the only valid argument for using Shift-JIS on Windows 9x:
</p><ul>
	<li><q>Compatibility with standard <code>char*</code> string handling</q> doesn't count (this is an argument against UTF-16, not against UTF-8)</li>
	<li><q>Rendered width = (<code>strlen()</code>&nbsp;× (full-width block size&nbsp;/ 2))</q> doesn't count (breaks with the proportional fonts your localizers want to use; just use <code>GetTextExtentPoint32W()</code>, it works on 9x too)</li>
	<li><q>B-but Han unification!1!!</q> doesn't count (you control the font, and Unicode still supports lossless conversion from and to Shift-JIS)</li>
</ul><p>
	So even if devs absolutely wanted to use Shift-JIS as the on-disk format, converting to UTF-16 at runtime and calling the Unicode versions of the GDI text rendering functions would have been better than using their <code>*A()</code> versions. Then, Windows 9x users could have fixed empty text boxes by properly installing codepage 932, XP users would have only needed to check that one <i>Install files for East Asian languages</i> box, and it all would have just worked without requiring the unbearable cringe of locale emulation. The <code>*A()</code> versions had no reason to exist other than programmer convenience.
</p><p id="sjis-fns-{{.Date}}">
	Alright, so there's some theoretical way to get all rendered text to show up correctly on Windows 9x, regardless of locale. But what about…
</p><h4>The original Japanese filenames</h4><p>
	Without a proper <code>CreateFileW()</code>, this is where we hit all the problems we were expecting. How <i>should</i> these behave on systems with non-Japanese codepages? Are we OK with turning old replay file names like <code lang="ja">秋霜りぷEx.DAT</code> into <code>????Ex.DAT</code>, and consequently <code>____Ex.DAT</code> due to question marks not being allowed in file names? This looks like the best choice we have: It's also what <code>unicows.dll</code> does right now, and it has the advantage of being easy to manually type.<br>
	It also is better than returning to the game's original behavior of blindly reinterpreting the bytes in the system codepage, which would turn the string into <code>H‘š‚è‚ÕEx.DAT</code> on codepage 1252. If you run pbg's original build on Western Windows 98, you'll see that it actually won't save <i>any</i> file whose name starts with the <code lang="ja">秋</code> kanji. Apparently, 9x kernels are much stricter than NT kernels when it comes to filenames in the system codepage and will outright refuse to create a file if it contains unassigned codepoints? The Shift-JIS lead byte of <code lang="ja">秋</code> is <code>0x8F</code>, <a href="https://en.wikipedia.org/wiki/Windows-1252">which is unused in CP1252</a>.
</p><p>
	Then again, if we had <a class="goal" href="https://github.com/nmlgc/ssg/issues/17">better replay-related error reporting</a>, the specific file names probably wouldn't matter because we'd just display them on screen. Given that {{Blog_PostLink "2023-08-01#config" "our forward-compatible configuration format"}} only uses ASCII characters on purpose and <a class="goal" href="https://github.com/nmlgc/ssg/issues/36">the new replay format</a> will do the same, this would only ever matter for the initial upgrade. There will be the possibility of converting future replays back into the original format for validation purposes, but that feature would ideally use exactly the names that the original game uses on the current system: Japanese names in Japanese locale, nothing on Western Windows 98, and mojibake everywhere else. Maybe we could even add a menu option to let players pick among all possible broken file names? {{HTML_Emoji "onricdennat"}}<br>
	But shouldn't we at least retain support for loading from original names when running the Windows 98 build on an NT kernel? Sure, the goal is a backport to Windows 98, but functional Unicode makes Windows XP a much more reasonable retro target. It sure makes a lot more sense than supporting XP with the regular, non-suffixed modern build: XP is almost identical to 98 in terms of SDL backends, being just as limited to Direct3D 9, WinMM, and DirectSound in the graphics and sound department. The only additional backend for XP would be <a href="https://learn.microsoft.com/en-us/windows/win32/inputdev/raw-input">Raw Input</a>, and we could just enable that one conditionally.
</p><p id="sjis-unicows-{{.Date}}">
	So how about just…
</p><h4>Leaving it all to <code>unicows.dll</code>?</h4><p>
	Yeah, why don't we just directly link both SDL and the game against the Microsoft Layer for Unicode, without relying on KernelEx injecting it for us? Then, SDL could just continue using Unicode APIs without us having to rewrite anything. And since MSLU disables itself on NT kernels, you'd still get the <span lang="ja">秋霜玉</span> window title and support for the original Japanese filenames regardless of the non-Unicode codepage. Heck, <code>unicows.lib</code> is still shipped with current Visual Studio. I'd only have to add a single linker flag and be done with it!<br>
	But when I tried this, the game broke in every environment:
</p><ul>
	<li>DxWnd failed to hook about half of the functions. It applied the configured window size, but failed to bypass the display mode change. There might be some permutation of tweaking options that fixes this issue, but good luck finding it. I tried all the hook-related options that sounded like they could help, but no dice.</li>
	<li>On Windows 98, the game crashed even when run without an external windowing tool due to an unfortunate combination of SDL and MSLU features:<ul>
		<li>SDL's renderers can be initialized into an existing Win32 window.</li>
		<li>This means that SDL will handle all events that the system sends to this window.</li>
		<li>However, the window might have set up a custom <a href="https://en.wikipedia.org/wiki/WindowProc">window proc</a> to handle certain events outside of SDL. It might be a good idea to still run this code and not have SDL take exclusive control.</li>
		<li>Due to the whole ANSI-vs.-Unicode mess, doing this requires a dedicated <i>subclassing</i> mechanism. By using <a href="https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-callwindowprocw"><code>CallWindowProc()</code></a> on <a href="https://devblogs.microsoft.com/oldnewthing/20031201-00/?p=41673">magic cookie values</a>, Windows allows ANSI window procs to subclass Unicode window procs and vice versa.</li>
		<li>However, MSLU uses the same subclassing mechanism to provide Unicode↔codepage wrappers for all events that carry string data. Since it hooks window creation, it goes first, subclassing the window proc that SDL specified in the window class structure.</li>
		<li>Then, it's SDL's turn to check whether it needs to subclass the window. It would only need to do so if the window proc differs from its own, which should only ever be the case if the window wasn't created through SDL, but, um…<figure>
			<pre>// Remember the previous window proc in case we have to subclass it
WNDPROC superclass_wndproc = GetWindowLong(hwnd, GWL_WNDPROC);
if (superclass_wndproc == SDL_WIN_WindowProc) {
    // Window uses our window class and wasn't subclassed. Nothing to do.
    superclass_wndproc = NULL;
} else {
    // Window already has a foreign window proc. Move us back to the top
    // of the hierarchy to ensure that we handle the messages we care
    // about. Surely no one subclassed us between CreateWindow() and now?
    SetWindowLong(hwnd, GWL_WNDPROC, SDL_WIN_WindowProc);
}</pre><figcaption>
			Adapted from <code>SDL_windowswindow.c</code>.
		</figcaption></figure></li>
		<li>Now, both MSLU and SDL think that their own window proc is a subclass of the other one. Thus, both of them call the other one using <code>CallWindowProc()</code>, expecting it to terminate the chain…</li>
		<li>…but since neither of them does, the resulting infinite recursion ends up crashing the game with a stack overflow. 💥</li>
	</ul>
</ul><p>
	Maybe this could be considered a fixable bug that traces back to SDL 1, but the whole situation is just very silly. If this had worked, we would be running the Windows 9x build through up to three separate layers of dynamically patched code – KernelEx, MSLU, and D3DWindower – when we'd like to have at most one and ideally zero. Besides, we <i>know</i> which code we want to run, we <i>know</i> that we don't need to reach for subclassing to make it all work, and we <i>know</i> that SDL is the ideal place for it. Now we just have to write it all.
</p><p>
	Until then, this is where we are right now:
</p><p>
	<a class="release" href="https://github.com/nmlgc/ssg/releases/tag/P0310">
	{{HTML_Emoji "sh01"}} Shuusou Gyoku P0310 Windows build</a>
</p><p>
	Next up: The long-awaited return to TH03! With {{HTML_Currency 34500}} per month going explicitly toward that game now, we'll definitely stay there for a while. {{DB_CustomerByID 13}} is generously funding short-term and long-term netplay options, so let's finish <code>OP.EXE</code> in preparation for nice and user-friendly menus. This is the last main menu to be decompiled across all of PC-98 Touhou and it's mostly text-based, so how hard can it be?
</p>
